\DoxyHorRuler{0}
\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Introduction}\label{md__r_e_a_d_m_e_autotoc_md1}
The final assignment deals with a robot moving into an initlially {\bfseries{unknown}} enviroment. Depending on the mode selected, the robot can {\bfseries{drive autonomously, reaching a given goal}}, {\bfseries{being driven by the user}} and {\bfseries{being driven by the user, assisting them to avoid collisions}}.\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Installing and running}\label{md__r_e_a_d_m_e_autotoc_md2}
The simulator requires \href{http://wiki.ros.org}{\texttt{ {\bfseries{R\+OS}}}} ({\bfseries{Robot-\/\+Operating-\/\+Systems}}) to be installed on the machine. In particular, the \href{http://wiki.ros.org/noetic/Installation}{\texttt{ Noetic Release of R\+OS}} was used.

For this particular simulation there are some required elements\+:
\begin{DoxyItemize}
\item \href{https://github.com/CarmineD8/slam_gmapping}{\texttt{ Slam Gmappic package}}
\item ros navigation stack
\item xterm
\end{DoxyItemize}

If you don\textquotesingle{}t have any of these elements you can run the following instructions\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ git clone https://github.com/CarmineD8/slam\_gmapping.git}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo apt-\/get install ros-\/<your\_ros\_distro>-\/navigation}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo apt install xterm}
\end{DoxyCode}


After doing that, you are ready to {\bfseries{launch the simulation!}} A launch file, called {\ttfamily launcher.\+launch}, is provided to run all the required nodes.

this is its structure\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<\textcolor{keywordtype}{launch}>}
\DoxyCodeLine{    <\textcolor{keywordtype}{include} \textcolor{keyword}{file}=\textcolor{stringliteral}{"\$(find RT2\_Assignment)/launch/simulation\_gmapping.launch"}/>}
\DoxyCodeLine{    <\textcolor{keywordtype}{include} \textcolor{keyword}{file}=\textcolor{stringliteral}{"\$(find RT2\_Assignment)/launch/move\_base.launch"}/>}
\DoxyCodeLine{    <\textcolor{keywordtype}{node} \textcolor{keyword}{pkg}=\textcolor{stringliteral}{"RT2\_Assignment"} \textcolor{keyword}{type}=\textcolor{stringliteral}{"mainController"} \textcolor{keyword}{name}=\textcolor{stringliteral}{"mainController"} \textcolor{keyword}{output}=\textcolor{stringliteral}{"screen"} \textcolor{keyword}{required}=\textcolor{stringliteral}{"true"} \textcolor{keyword}{launch-\/prefix}=\textcolor{stringliteral}{"xterm -\/fa 'Monospace' -\/fs 11 -\/e"}/>}
\DoxyCodeLine{</\textcolor{keywordtype}{launch}>}
\end{DoxyCode}


Notice that {\ttfamily launch-\/prefix} of main\+Controller node contains some rules regarding the font family and the font size, you are completely free to change it!\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{Simulation environment}\label{md__r_e_a_d_m_e_autotoc_md3}
After launching the simulation using the provided commands two programs will open, \href{http://gazebosim.org/}{\texttt{ {\bfseries{Gazebo}}}} and \href{http://wiki.ros.org/rviz}{\texttt{ {\bfseries{Rviz}}}}.

Gazebo is an open-\/source 3D robot simulator. Here\textquotesingle{}s the simulation view from Gazebo\+:



R\+OS generate the environment based on the file {\ttfamily house.\+world}, stored into the {\bfseries{world}} folder.

Initially the robot knows only what he can see, here\textquotesingle{}s the image showing his initial known map.



After some time the robot has explored and mapped all the surrounding walls using his laser scan.

We can now see the full map into rviz, as shown below\+:

\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysection{Main\+Controller node}\label{md__r_e_a_d_m_e_autotoc_md4}
The main\+Controller node is the first node, spawned with the {\ttfamily launcher.\+launch} file. This node simply prompts some instruction in the xterm console, then it detects and interprets the user inputs.

The user can\+:
\begin{DoxyItemize}
\item {\bfseries{1}} -\/ Reach autonomousely a given position
\item {\bfseries{2}} -\/ Drive the robot with the keyboard
\item {\bfseries{3}} -\/ Drive the robot with the keyboard with automatic collision avoidance
\item {\bfseries{4}} -\/ Reset simulation
\item {\bfseries{0}} -\/ Exit from the program
\end{DoxyItemize}

Generally speaking, this simulation includes a non-\/blocking getchar function, ideal to speed up the program execution and to improve the user execution.

I found this function in \href{https://github.com/methylDragon/teleop_twist_keyboard_cpp/blob/master/src/teleop_twist_keyboard.cpp}{\texttt{ teleop\+\_\+twist\+\_\+keyboard\+\_\+cpp repository}}, and it temporarily edits the system settings in order to catch immediately what the user writes.

Remember that the {\ttfamily termios.\+h} library is required, so don\textquotesingle{}t remove it!

Finally, based on the input received, the main\+Controller node runs the selected node, using {\ttfamily system()} function.

For example, if the number 1 is pressed, this command is executed\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{system(\textcolor{stringliteral}{"rosrun RT2\_Assignment reachPoint"});}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysection{Reach\+Point node}\label{md__r_e_a_d_m_e_autotoc_md5}
The reach\+Point node implements the first required feature. In fact it set a new goal for the robot according to what the user wants.

At his initial state, the node request the x and y coordinates of the goal, then it generates a new message of type {\ttfamily move\+\_\+base\+\_\+msgs/\+Move\+Base\+Action\+Goal}. The message is then published into the {\ttfamily /move\+\_\+base/goal} topic.

When the message is published, the robot starts looking for a valid path which can lead to the goal, and he followes it.

During the navigation, the user can at any time\+:
\begin{DoxyItemize}
\item stop the navigation by pressing the {\bfseries{q}} key, or
\item exit the node by pressing {\bfseries{C\+T\+R\+L-\/C}} key
\end{DoxyItemize}

If one of this keys is pressed, a message of type {\ttfamily actionlib\+\_\+msgs/\+Goal\+ID} is generated and then published into the {\ttfamily /move\+\_\+base/cancel} topic. In particular, every goal is tracked by the node with its {\bfseries{id}}, randomly generated by the node itself using {\ttfamily rand()} function, so sending the goal cancel message is quite easy.

In order to know if the robot has reached the goal or if the robot can\textquotesingle{}t reach it a {\ttfamily /move\+\_\+base/status} message handler is implemented. It continousely checks the messages published into that topic, in particular it looks for the {\bfseries{status}} code.

Initially the status code is {\bfseries{1}}, meaning that the robot is following his path. When the robot stop there are two possibilities\+: if the code is equal {\bfseries{3 (succeded)}} then it means that the goal has been successfully reached, otherwise if the robot can\textquotesingle{}t reach the goal the status code will be set to {\bfseries{4 (aborted)}}.

Based on the code the node displays the result in the console, then it asks if the user wants to select a new goal or exit from this node.\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysection{Drive\+With\+Keyboard node}\label{md__r_e_a_d_m_e_autotoc_md6}
The drive\+With\+Keyboard node let the user drive the robot using the keyboard.

Here, I decided to {\bfseries{edit the teleop\+\_\+twist\+\_\+keyboard}} node, starting from the {\ttfamily .cpp} version which I found in the \href{https://github.com/methylDragon/teleop_twist_keyboard_cpp/blob/master/src/teleop_twist_keyboard.cpp}{\texttt{ teleop\+\_\+twist\+\_\+keyboard\+\_\+cpp repository}}.

In particular I clean the user interface, and I added the possibility to reset the linear and the angular speed. Also there\textquotesingle{}s a new possibility to safely quit from the execution using C\+T\+R\+L-\/C combination.

The node simply checks the user imputs according to the instructions prompted in the console, and it publish the new speed to the {\ttfamily /cmd\+\_\+vel} topic.

The speed is computed as the relative speed multiplied with the selected direction, which is an integer defined between -\/1 and 1. 1 means that the robot must go forward or turn left, -\/1 means backward (or turn right), 0 means stop.

Here\textquotesingle{}s the computations in terms of code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//define variables for vel direction}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{drive_with_keyboard_8cpp_aed6efd15a611832e8335a27a1c93795a}{lin}}=0; \textcolor{comment}{//linear direction}}
\DoxyCodeLine{\textcolor{keywordtype}{int} \mbox{\hyperlink{drive_with_keyboard_8cpp_a4365545fd48c51e8d4fa9ebb99c6a72f}{ang}} =0; \textcolor{comment}{//angular direction}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{drive_with_keyboard_8cpp_af113e9b4ca3af68972dfd3df47898c83}{vel}}.angular.z = \mbox{\hyperlink{drive_with_keyboard_8cpp_ae9b28d6b588b124dc762dc9a3c29619e}{turn\_speed}} * \mbox{\hyperlink{drive_with_keyboard_8cpp_a4365545fd48c51e8d4fa9ebb99c6a72f}{ang}};}
\DoxyCodeLine{\mbox{\hyperlink{drive_with_keyboard_8cpp_af113e9b4ca3af68972dfd3df47898c83}{vel}}.linear.x = \mbox{\hyperlink{drive_with_keyboard_8cpp_a6dc6e6f3c75c509ce943163afb5dade7}{speed}} * \mbox{\hyperlink{drive_with_keyboard_8cpp_aed6efd15a611832e8335a27a1c93795a}{lin}};}
\end{DoxyCode}


The user can use a 3x3 input keys as they are a \char`\"{}joystick\char`\"{}. Here\textquotesingle{}s the keys\+: \begin{center}\end{center} 

\begin{center}\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Turn left }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Don\textquotesingle{}t turn }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Turn right  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Turn left }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Don\textquotesingle{}t turn }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Turn right  }\\\cline{1-4}
\endhead
\PBS\centering {\bfseries{Go forward}} &\PBS\centering u &\PBS\centering i &\PBS\centering o  \\\cline{1-4}
\PBS\centering {\bfseries{Dont\textquotesingle{} go}} &\PBS\centering j &\PBS\centering k &\PBS\centering l  \\\cline{1-4}
\PBS\centering {\bfseries{Go backward}} &\PBS\centering m &\PBS\centering , &\PBS\centering .  \\\cline{1-4}
\end{longtabu}
\end{center} 

\begin{center}\end{center} 

Also, the user can set the robot linear and angular joystick, using this set of commands\+:

\begin{center}\end{center} 

\begin{center}\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change linear and angular }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change linear only }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change angular only  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change linear and angular }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change linear only }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Change angular only  }\\\cline{1-4}
\endhead
\PBS\centering {\bfseries{Increase}} &\PBS\centering q &\PBS\centering w &\PBS\centering e  \\\cline{1-4}
\PBS\centering {\bfseries{Reset}} &\PBS\centering a &\PBS\centering s &\PBS\centering d  \\\cline{1-4}
\PBS\centering {\bfseries{Decrease}} &\PBS\centering z &\PBS\centering x &\PBS\centering c  \\\cline{1-4}
\end{longtabu}
\end{center} 

\begin{center}\end{center} \hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysection{Drive\+With\+Keyboard\+Assisted node}\label{md__r_e_a_d_m_e_autotoc_md7}
The drive\+With\+Keyboard\+Assisted node, similar to the node above, let the user drive the robot using the keyboard, {\bfseries{assisting him during the navigation}}.

In particular, the node reads the same identical user inputs as the drive\+With\+Keyboard node, but it also checks what the robot\textquotesingle{}s laser scanner sees. To do so, the node subscribes to the {\ttfamily /scan} topic, and it uses the message received to detect walls too close to the robot. This topic is composed by 720 {\itshape ranges}, in which there are all the detected distances. the sensor can see from -\/90 to 90 degrees, so each sensor has 1/4 of degree of view.

After a message from {\ttfamily /scan} is recieved, the node enters inside the {\ttfamily check\+Walls} function, that filters all the ranges taking only the one from\+:
\begin{DoxyItemize}
\item -\/90° to -\/55° referred to the walls on the right,
\item -\/17.\+5° to 17.\+5° referred to the walls in front of the robot,
\item 55° to 90° referred to the walls on the left.
\end{DoxyItemize}

The function then checks the minimum distance inside this ranges, and if a wall is closer than {\ttfamily wall\+\_\+th = 1 (meter)} it prevents the robot from getting too close to it. In particulat, if the front wall is too close the robot can\textquotesingle{}t advance, while if one of the walls on the left or on the right is too close the robot can\textquotesingle{}t turn in that direction.

To actuate this security feature the functions simply edits the linear and angualar direction according to the rules above, setting them to {\bfseries{0}} when required.

Finally, a {\bfseries{red danger warning string}} is prompted to the user.\hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysection{Flowchart}\label{md__r_e_a_d_m_e_autotoc_md8}
$<$image src=\char`\"{}https\+://github.\+com/marcomacchia99/\+R\+T1\+\_\+\+Assignment2/blob/main/assets/diagram.\+png\char`\"{} width=\char`\"{}600px\char`\"{}$>$\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysection{Project graph}\label{md__r_e_a_d_m_e_autotoc_md9}
Here\textquotesingle{}s the project graph which explains the relationship within the nodes. The graph can be generated using this command\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ rqt\_graph}
\end{DoxyCode}


\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysection{Conclusion and future improvements}\label{md__r_e_a_d_m_e_autotoc_md10}
By now the robot can autonomousely drive inside the \href{https://www.monzanet.it/}{\texttt{ Autodromo Nazionale di Monza}}, but all the movement aren\textquotesingle{}t smooth at all. A next update could introduce better movements inside the turn, expecially inside the {\itshape Prima variante}, and a bettere {\itshape user experience}.

It could also be possibile to dynamically change the robot speed, as the real cars actually do\+: The robot can drive at a speed that is inversely proportional to the amount of remaining straight. In this case however, the user input will became useless. 